{$include_once SRL/OSR.simba}
{$I minimap.simba}
{==============================================================================]
 Note:
   This is an early version, there might exist bugs. It also means that
   variable-, type-, function-names and the structure in this file is not final.

   Over time there might come several changes, mainly for the better.

   (I know the record names are a mess)

   Debug defines:
     OW:DEBUG       -> Nothing atm..
     OW:DEBUG_WORDY -> Will write some text, for example if it can't find a DTM
     OW:SMARTDEBUG  -> Will draw to the smartimage.
     OW:DEBUG_TIMES -> Will write some timings..
[==============================================================================}
type
  TFeaturePoint = record
    typ: EMinimapObject;
    x,y: Int32;
  end;
  TMMDTM = array of TFeaturePoint;

  TMMObjects = record
    typ: EMinimapObject;
    TPA: TPointArray;
  end;
  TMMObjectsArray = array of TMMObjects;

  TFoundFeatures = record
    arr:TPointArray;
    scale,theta:Double;
  end;

  TPathPoint = record
    Features: TMMDTM;
    Points: TPointArray; //one set of features can cover several points.
  end;
  TMMPath = array of TPathPoint;

  TObjectWalk = record
    Types: TIntegerArray;
    MaxOffset, MaxInaccuracy, MaxScale: Double;
  end;

  TLine = record p,q:TPoint; end;


const
  //16 high pitch colors that should genrally show well on the minimap.
  COLOR_LIST16: TIntegerArray = [
      $0000ff, $00ff44, $eeff00, $ff0066, $6666ff, $55ffff, $f5ff66, $ff66a3,
      $00bbff, $5555DD, $ff5500, $dd00ff, $66d6ff, $85ff66, $ff9966, $eb66ff
  ];


function TMMDTM.RotateToCompass(): TMMDTM; constref;
var
  i:Int32;
  pt:TPoint;
begin
  SetLength(Result, Length(self));
  for i:=0 to High(self) do
  begin
    pt := Point(self[i].x,self[i].y);
    pt := RotatePoint(pt, Minimap.GetCompassAngle(False), self[0].x,self[0].y);
    Result[i].x := pt.x;
    Result[i].y := pt.y;
    Result[i].typ := self[i].typ;
  end;
end;

(*
  This is our magic friend that made it all possible. It's where it all started.

  Note to self:
    We can return many results, and sort them from the "expected" location when
    walking, this should make walking pretty much flawless, even tho duplicates exists.

    For anything else, we'd just use the first result, and assume the user has
    defined enough feature points to never return duplicates.
*)
function TMMDTM.FindEx(Objects:TMMObjectsArray; radius:Double=180; sm:Double=1.15; eps:Double=3): TFoundFeatures; constref;
type
  TNode = record
    typ:EMinimapObject;
    R,T:Double;
  end;
var
  i,j,k:Int32;
  dist1,dist2,angle1,angle2,newA,newD,offset,scale:Double;
  pts:array of TNode;
  candidates,TPA,tmp,path:TPointArray;
  mp,pt,newPt:TPoint;

  function GetObjectPoints(typ:EMinimapObject; out points: TPointArray): Boolean;
  var i:Int32;
  begin
    for i:=0 to High(Objects) do
      if Objects[i].typ = typ then
      begin
        points := Copy(Objects[i].TPA);
        Result := True;
      end;
  end;

  function Nearest(TPA:TPointArray; p:TPoint): TPoint;
  var q:TPoint; d,h:Double = 9999999;
  begin
    for q in TPA do
    begin
      h := Hypot(q.x-p.x,q.y-p.y);
      if h < d then
      begin
        d := h;
        Result := q;
      end;
    end;
  end;
begin
  radius := Radians(radius+3);

  for i:=1 to High(self) do
  begin
    pt.x := self[0].x - self[i].x;
    pt.y := self[0].y - self[i].y;

    pts += TNode([
      self[i].typ,
      Hypot(pt.y, pt.x),
      ArcTan2(pt.y, pt.x)
    ]);
  end;

  for i:=0 to High(Objects) do
    if (Objects[i].typ = self[0].typ) then
    begin
      candidates := objects[i].TPA;
      break;
    end;


  for i:=0 to High(candidates) do
  begin
    //assumed mainPoint
    mp := candidates[i];

    //grab inital points to start of
    dist1  := pts[0].R;
    angle1 := pts[0].T;

    if not GetObjectPoints(pts[0].typ, TPA) then Exit();
    FilterPointsDist(TPA, dist1*1/sm, dist1*sm, mp.x,mp.y);

    //loop init
    SetLength(path, 2);
    path[0] := mp;

    for k:=0 to High(TPA) do //all of these are point[1] candidates
    begin
      TPA[k].Offset(Point(-mp.x,-mp.y)); //zero based.

      dist2 := Hypot(TPA[k].x,TPA[k].y);
      scale := 1+(dist2-dist1) / dist1;
      angle2 := ArcTan2(TPA[k].y, TPA[k].x);
      offset := srl.DeltaAngle(angle2,angle1,PI*2);

      if (Abs(-PI+offset) > radius) and (Abs(+PI+offset) > radius) then
        continue;

      path[1] := TPA[k] + mp;

      for j:=1 to High(pts) do
      begin
        //build expected location:
        newA := pts[j].T + offset;
        newD := pts[j].R * scale;
        newPt := Point(mp.x+Round(newD * Cos(newA)), mp.y+Round(newD * Sin(newA)));

        //lookup the nearest point to that location:
        if not GetObjectPoints(pts[j].typ, tmp) then Exit();
        pt := Nearest(tmp, newPt);

        if Hypot(pt.x-newPt.x, pt.y-newPt.y) < eps then
          path += pt
        else
          break;
      end;

      if Length(path) = Length(self) then
      begin
        Result.arr   := path;
        Result.scale := scale;
        Result.theta := offset;
        Exit();
      end;
      SetLength(path, 2);
    end;
  end;
end;

(*
  this is the function above, just does ous the favor of finding minimap objects
  first. It will only look for the objects that is used in the "DTM" (TMMDTM)
*)
function TMMDTM.Find(radius:Double=180; sm:Double=1.15; eps:Double=3): TFoundFeatures; constref;
var
  i:Int32;
  test:TIntegerArray;
  MMObjects:TMMObjectsArray;
begin
  for i:=0 to High(self) do
  begin
    if test.Find(Ord(self[i].typ)) >= 0 then Continue;
    test += Ord(self[i].typ);
  end;

  for i in Test do
    MMObjects += TMMObjects([EMinimapObject(i), Minimap.FindObj(MMObjRecords[i])]);

  Result := self.FindEx(MMObjects, radius,sm,eps);
end;


//So.. yeah.. we like initalizers.. :)
procedure TObjectWalk.Init();
var
  i,j: Int32;
  mp:TPoint;
begin
  self.MaxOffset := 15;          //How much the minimap can offset in relation to the compass.
  self.MaxInaccuracy := 2.7;     //With rotation, slightly inaccurate object finding and other defomities, we need to allow a little inaccuracy.
  self.MaxScale := 1.13;         //minimap scales, from 0.95 to 1.05 (10%), so we allow 13% scaling of our feature points (3% more than what can be, to be on the safeside).
end;


function TObjectWalk.IsFlagPresent(searchTime:Int32=500): Boolean; static;
var
  TPA: TPointArray;
  B:TBox := [570,9,714,159];
  t:Int64;
begin
  Result := False;
  t := GetTickCount64() + searchTime;
  while GetTickCount64() < t do
    if FindColorsTolerance(TPA, 255, B.x1,B.y1,B.x2,B.y2, 1) then
      for TPA in SplitTPA(TPA,1) do
        if (Length(TPA) >= 10) and (Length(TPA) <= 50) then
          Exit(True);
end;


(*
 Meh.. these two methods aren't really used, but I might need them for
 debugging later on
*)
function TObjectWalk.FindObjects(ObjIds: TIntegerArray): TMMObjectsArray; static;
var typ:Int32;
begin
  for typ in ObjIds do
    Result += TMMObjects([EMinimapObject(typ), Minimap.FindObj(MMObjRecords[typ])]);
end;

function TObjectWalk.FindObjects(DTM: TMMDTM): TMMObjectsArray; static; overload;
var
  i:Int32;
  test:TIntegerArray;
begin
  for i:=0 to High(DTM) do
  begin
    if test.Find(Ord(DTM[i].typ)) >= 0 then
      Continue;

    Result += TMMObjects([DTM[i].typ, Minimap.FindObj(MMObjRecords[DTM[i].typ])]);
    test += Ord(DTM[i].typ);
  end;
end;


(*
  Ugh.. the input points gotta be scaled and rotated in relation to where we found
  the DTM, it's scale, and the minimap-offset-to-compass
*)
function TObjectWalk.AdjustPoint(pt:TPoint; mp:TPoint; theta,scale:Double): TPoint; static;
var
  p:PPoint;
begin
  p.R := Hypot(pt.y, pt.x) * scale;
  p.T := ArcTan2(pt.y, pt.x) + (PI + theta + minimap.GetCompassAngle(False));
  Result := Point(Round(mp.x + p.r * Cos(p.t)), Round(mp.y + p.r * Sin(p.t)));
end;

function TObjectWalk.AdjustBlindPoint(pt:TPoint; theta,scale:Double): TPoint; static;
var
  p:PPoint;
begin
  pt -= minimap.Center;
  p.R := Hypot(pt.y, pt.x) * scale;
  p.T := ArcTan2(pt.y, pt.x) + (PI + theta + minimap.GetCompassAngle(False));
  Result := Point(Round(minimap.Center.x + p.r * Cos(p.t)), Round(minimap.Center.y + p.r * Sin(p.t)));
end;

function TObjectWalk.FindDTM(out Res:TFoundFeatures; DTM:TMMDTM; MaxTime:Int32=3500): Boolean; constref;
var
  t:Int64;
begin
  Res := [];
  t := GetTickCount()+MaxTime;
  while (GetTickCount() < t) and (Res.Arr = []) do
  begin
    Res := DTM.RotateToCompass().Find(self.MaxOffset, self.MaxScale, self.MaxInaccuracy);
    if Res.Arr = [] then Wait(60);
  end;
  Result := Res.Arr <> [];
end;

(*
  Just a neat function to have..
  It locates the "goal" point taking into account all minimap transformations..
  Then it returns the distance from you (at minimap center) to this point.
*)
function TObjectWalk.DistanceTo(Goal:TPoint; DTM:TMMDTM): Double; constref;
var
  F:TFoundFeatures;
  other,me:TPoint;
  i:Int32;
begin
  Goal.x -= DTM[0].x;
  Goal.y -= DTM[0].y;
  me := minimap.Center;
  if not self.FindDTM(F, DTM) then
    Exit(-1);

  other := self.AdjustPoint(Goal, F.arr[0], F.theta, F.scale);
  Result := Hypot(me.x-other.x, me.y-other.y);
end;

(*
  Yeah.. this one is supersimple, with no random at all (this is a prototype after all).
*)

procedure TObjectWalk.WalkTo(pt:TPoint{$IFDEF OW:SMARTDEBUG}; step:TPoint; DTM:TMMDTM{$ENDIF}); constref;
begin
  {$IFDEF OW:SMARTDEBUG}self.DebugDTM(step, DTM, Smart.Image);{$ENDIF}
  Mouse.Click(pt,1);
  while self.IsFlagPresent() do
  begin
    {$IFDEF OW:SMARTDEBUG}
      self.DebugDTM(step, DTM, Smart.Image);
      Wait(7);
    {$ELSE}
      Wait(70);
    {$ENDIF}
  end;

  {$IFDEF OW:SMARTDEBUG}
    smart.Image.DrawClear(0);
  {$ENDIF}
end;

(*
  This is your best friend. It will walk the minimap up, down, and sideways, yo!
*)
function TObjectWalk.Walk(Path:TMMPath): Boolean; constref;
var
  i:Int32;
  step,pt:TPoint;
  F:TFoundFeatures;
  theta,scale:Double;
begin
  theta := PI;
  scale := 1;

  for i:=0 to High(Path) do
    for step in Path[i].Points do
    begin
      if Length(Path[i].Features) = 0 then //blind step
      begin
        pt := self.AdjustBlindPoint(step, theta, scale);
        self.WalkTo(pt{$IFDEF OW:SMARTDEBUG},step,Path[i].Features{$ENDIF});
        continue;
      end;

      for 0 to 19 do
      begin
        {$IFDEF OW:SMARTDEBUG}
          if not self.DebugDTM(step, Path[i].Features, Smart.Image) then
            Smart.Image.DrawClear(0);
        {$ENDIF}

        if not self.FindDTM(F,Path[i].Features) then
        begin
          {$IFDEF OW:DEBUG_WORDY}WriteLn('Warning: Unable to find DTM ', i);{$ENDIF}
          Exit(False);
        end;

        pt.x := step.x - Path[i].Features[0].x;
        pt.y := step.y - Path[i].Features[0].y;
        pt := self.AdjustPoint(pt, F.arr[0], F.theta, F.scale);

        {$IFDEF OW:SMARTDEBUG}
          Smart.Image.DrawClear(0);
        {$ENDIF}

        if Distance(Minimap.Center, pt) <= 65 then Break;
        Wait(50);
      end;
      self.WalkTo(pt{$IFDEF OW:SMARTDEBUG},step,Path[i].Features{$ENDIF});

      theta := F.theta;
      scale := F.scale;
    end;
  Result := True;
end;



(*==| FOR DEBUGGING BELLOW THIS LINE |========================================*)
(*============================================================================*)

var
  __MMMask__:TPointArray := ReturnPointsNotInTPA(Minimap.MaskTPA, GetTPABounds(Minimap.MaskTPA));


procedure TObjectWalk.DebugMinimap(im:TMufasaBitmap; offset:TPoint=[0,0]; Clear:Boolean=True); constref;
var
  objects: T2DPointArray;
  color,i:Int32;
  pt:TPoint;
  b:TBox;
  {$IFDEF OW:DEBUG_TIMES} t:TDateTime;{$ENDIF}
begin
  for i:=0 to High(MMObjRecords) do
  begin
    {$IFDEF OW:DEBUG_TIMES}t := Now();{$ENDIF}
    objects += Minimap.FindObj(MMObjRecords[i]);
    {$IFDEF OW:DEBUG_TIMES}WriteLn('Finding ', EMinimapObject(i), ' used: ', FormatDateTime('z', Now()-t),'ms');{$ENDIF}
  end;

  if Clear and (offset = [0,0]) then im.DrawTPA(__MMMask__, 0);
  for i:=0 to High(objects) do
    for pt in objects[i] do
    begin
      color := COLOR_LIST16[i mod 16];
      pt += offset;
      try
      Im.DrawTPA(TPAFromBox(Box(pt.x-1,pt.y-1,pt.x+1,pt.y+1)), color);
      except
      end;
    end;
end;


function TObjectWalk.DebugDTM(Goal:TPoint; DTM:TMMDTM; im:TMufasaBitmap; offset:TPoint=[0,0]; Clear:Boolean=True): Boolean; constref;
var
  F:TFoundFeatures;
  line:TPointArray;
  found,p,q:TPoint;
  i,color:Int32;
begin
  if Length(DTM) = 0 then Exit();
  Result := True;
  Goal.x -= DTM[0].x;
  Goal.y -= DTM[0].y;

  if not self.FindDTM(F, DTM) then
  begin
    {$IFDEF OW:DEBUG_WORDY}WriteLn('Unable to find DTM!');{$ENDIF}
    Exit(False);
  end;

  found := self.AdjustPoint(Goal, F.arr[0], F.theta, F.scale);
  found.Offset(offset);
  if Clear and (offset = [0,0]) then im.DrawTPA(__MMMask__, 0);

  Im.DrawTPA(TPAFromBox(Box(found.x-1, found.y-1,found.x+1, found.y+1)), COLOR_LIST16[0]);
  line := TPAFromLine(found.x, found.y, Minimap.Center.x, Minimap.Center.y);
  for i:=3 to High(line)-1 with 4 do
  begin
    Im.SetPixel(line[i+0].x, line[i+0].y, $FFFFFF);
    Im.SetPixel(line[i+1].x, line[i+1].y, $FFFFFF);
  end;

  for i:=0 to High(F.arr) do
  begin
    p := F.arr[i] + offset;
    color := COLOR_LIST16[(i+1) mod 16];
    try
    Im.DrawTPA(TPAFromBox(Box(p.x-1, p.y-1,p.x+1,p.y+1)), color);
    except
    end;
    Im.DrawTPA(TPAFromLine(p.x,p.y,Minimap.Center.x,Minimap.Center.y), $999999);
  end;
end;

