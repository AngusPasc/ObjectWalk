{$include_once SRL/OSR.simba}
{$include_once SRL/utils/slacktree.simba}
{$I minimap.simba}
{==============================================================================]
 Note:
   This is an early version, there might exist bugs. It also means that
   variable-, type-, function-names and the structure in this file is not final.

   Over time there might come several changes, mainly for the better.

   (I know the record names are a mess)
[==============================================================================}
type
  TFeaturePoint = record
    typ: EMinimapObject;
    x,y: Int32;
  end;
  TMMDTM = array of TFeaturePoint;

  TMMObjects = record
    typ: EMinimapObject;
    TPA: TPointArray;
  end;
  TMMObjectsArray = array of TMMObjects;

  TFoundFeatures = record
    arr:TPointArray;
    scale,theta:Double;
  end;

  TPathPoint = record
    Features: TMMDTM;
    Points: TPointArray; //one set of features can cover several points.
  end;
  TMMPath = array of TPathPoint;

  TObjectWalk = record
    Types: TIntegerArray;
    MaxOffset, MaxInaccuracy, MaxScale: Double;
    Debugging: Boolean;
  end;

  TLine = record p,q:TPoint; end;


const
  //16 high pitch colors that should genrally show well on the minimap.
  COLOR_LIST16: TIntegerArray = [
      $0000ff, $00ff44, $eeff00, $ff0066, $6666ff, $55ffff, $f5ff66, $ff66a3,
      $00bbff, $5555DD, $ff5500, $dd00ff, $66d6ff, $85ff66, $ff9966, $eb66ff
  ];


function TMMDTM.RotateToCompass(): TMMDTM; constref;
var
  i:Int32;
  pt:TPoint;
begin
  SetLength(Result, Length(self));
  for i:=0 to High(self) do
  begin
    pt := Point(self[i].x,self[i].y);
    pt := RotatePoint(pt, Minimap.GetCompassAngle(False), self[0].x,self[0].y);
    Result[i].x := pt.x;
    Result[i].y := pt.y;
    Result[i].typ := self[i].typ;
  end;
end;

(*
  This is our magic friend that made it all possible. It's where it all started.

  Note to self:
    We can return many results, and sort them from the "expected" location when
    walking, this should make walking pretty much flawless, even tho duplicates exists.

    For anything else, we'd just use the first result, and assume the user has
    defined enough feature points to never return duplicates.
*)
function TMMDTM.FindEx(Objects:TMMObjectsArray; radius:Double=180; sm:Double=1.15; eps:Double=3): TFoundFeatures; constref;
type
  TNode = record
    typ:EMinimapObject;
    R,T:Double;
  end;
  TTree = record
    typ:EMinimapObject;
    tree:TSlackTree;
  end;
var
  treeList:array of TTree;
  tree:TSlackTree;
  i,j,k:Int32;
  dist1,dist2,angle1,angle2,newA,newD,offset,scale:Double;
  pts:array of TNode;
  candidates: TMMObjects;
  tmp,path:TPointArray;
  mp,pt,newPt:TPoint;

  function FindTree(typ:EMinimapObject; out tree: TSlackTree): Boolean;
  var i:Int32;
  begin
    for i:=0 to High(treeList) do
      if treeList[i].typ = typ then
      begin
        tree := treeList[i].Tree;
        Result := True;
      end;
  end;
begin
  radius := Radians(radius+3);

  for i:=1 to High(self) do
  begin
    pt.x := self[0].x - self[i].x;
    pt.y := self[0].y - self[i].y;

    pts += TNode([
      self[i].typ,
      Hypot(pt.y, pt.x),
      ArcTan2(pt.y, pt.x)
    ]);
  end;

  for i:=0 to High(Objects) do
    if Length(Objects[i].TPA) > 0 then
    begin
      j := Length(TreeList);
      SetLength(TreeList, j+1);
      TreeList[j].typ := Objects[i].typ;
      TreeList[j].tree.Init(Objects[i].TPA);
      if (Objects[i].typ = self[0].typ) then
        candidates := Objects[i];
    end;

  for i:=0 to High(candidates.TPA) do
  begin
    //assumed mainPoint
    mp := candidates.TPA[i];

    //grab inital points to start of
    dist1  := pts[0].R;
    angle1 := pts[0].T;

    if not FindTree(pts[0].typ, tree) then Exit();
    tmp := tree.RangeQueryEx(mp, dist1*1/sm,dist1*1/sm, dist1*sm,dist1*sm, False);

    //loop init
    SetLength(path, 2);
    path[0] := mp;

    for k:=0 to High(tmp) do //all of these are point[1] candidates
    begin
      tmp[k].Offset(Point(-mp.x,-mp.y)); //zero based.

      dist2 := Hypot(tmp[k].x,tmp[k].y);
      scale := 1+(dist2-dist1) / dist1;
      angle2 := ArcTan2(tmp[k].y, tmp[k].x);
      offset := srl.DeltaAngle(angle2,angle1,PI*2);

      if (Abs(-PI+offset) > radius) and (Abs(+PI+offset) > radius) then
        continue;

      path[1] := tmp[k];
      path[1].Offset(mp);

      for j:=1 to High(pts) do
      begin
        //build expected location:
        newA := pts[j].T + offset;
        newD := pts[j].R * scale;
        newPt := Point(mp.x+Round(newD * Cos(newA)), mp.y+Round(newD * Sin(newA)));

        //lookup hte nearest point to that location:
        if not FindTree(pts[j].typ, tree) then Exit();
        pt := tree.Nearest(newPt);

        if Hypot(pt.x-newPt.x, pt.y-newPt.y) < eps then
          path += pt;
      end;

      if Length(path) = Length(self) then
      begin
        Result.arr   := path;
        Result.scale := scale;
        Result.theta := offset;
        Exit();
      end;
      SetLength(path, 2);
    end;
  end;
end;

(*
  this is the function above, just does ous the favor of finding minimap objects
  first. It will only look for the objects that is used in the "DTM" (TMMDTM)
*)
function TMMDTM.Find(radius:Double=180; sm:Double=1.15; eps:Double=3): TFoundFeatures; constref;
var
  i:Int32;
  test:TIntegerArray;
  MMObjects:TMMObjectsArray;
begin
  for i:=0 to High(self) do
  begin
    if test.Find(Ord(self[i].typ)) >= 0 then
      Continue;
    MMObjects += TMMObjects([self[i].typ, Minimap.FindObj(MMObjRecords[self[i].typ])]);
    test += Ord(self[i].typ);
  end;
  Result := self.FindEx(MMObjects, radius,sm,eps);
end;


//So.. yeah.. we like initalizers.. :)
procedure TObjectWalk.Init(SmartDebug:Boolean=False);
var
  i,j: Int32;
  mp:TPoint;
begin
  self.Debugging := SmartDebug;  //
  self.MaxOffset := 15;          //How much the minimap can offset in relation to the compass.
  self.MaxInaccuracy := 2.7;     //With rotation, slightly inaccurate object finding and other defomities, we need to allow a little inaccuracy.
  self.MaxScale := 1.13;         //minimap scales, from 0.95 to 1.05 (10%), so we allow 13% scaling of our feature points (3% more than what can be, to be on the safeside).
end;


function TObjectWalk.IsFlagPresent(searchTime:Int32=500): Boolean; static;
var
  TPA: TPointArray;
  B:TBox := [570,9,714,159];
  t:Int64;
begin
  Result := False;
  t := GetTickCount64() + searchTime;
  while GetTickCount64() < t do
    if FindColorsTolerance(TPA, 255, B.x1,B.y1,B.x2,B.y2, 1) then
      for TPA in SplitTPA(TPA,1) do
        if (Length(TPA) >= 10) and (Length(TPA) <= 50) then
          Exit(True);
end;


(*
 Meh.. these two methods aren't really used, but I might need them for
 debugging later on
*)
function TObjectWalk.FindObjects(ObjIds: TIntegerArray): TMMObjectsArray; static;
var typ:Int32;
begin
  for typ in ObjIds do
    Result += TMMObjects([EMinimapObject(typ), Minimap.FindObj(MMObjRecords[typ])]);
end;

function TObjectWalk.FindObjects(DTM: TMMDTM): TMMObjectsArray; static; overload;
var
  i:Int32;
  test:TIntegerArray;
begin
  for i:=0 to High(DTM) do
  begin
    if test.Find(Ord(DTM[i].typ)) >= 0 then
      Continue;

    Result += TMMObjects([DTM[i].typ, Minimap.FindObj(MMObjRecords[DTM[i].typ])]);
    test += Ord(DTM[i].typ);
  end;
end;


(*
  Ugh.. the input points gotta be scaled and rotated in relation to where we found
  the DTM, it's scale, and the minimap-offset-to-compass
*)
function TObjectWalk.GetPoint(pt:TPoint; mp:TPoint; theta,scale:Double): TPoint; static;
var
  p:PPoint;
begin
  p.R := Hypot(pt.y, pt.x) * scale;
  p.T := ArcTan2(pt.y, pt.x) + (PI + theta + minimap.GetCompassAngle(False));
  Result := Point(Round(mp.x + p.r * Cos(p.t)), Round(mp.y + p.r * Sin(p.t)));
end;

function TObjectWalk.FindDTM(out Res:TFoundFeatures; DTM:TMMDTM; MaxTime:Int32=6000): Boolean; constref;
var
  t:Int64;
begin
  Res := [];
  t := GetTickCount()+MaxTime;
  while (GetTickCount() < t) and (Res.Arr = []) do
  begin
    Res := DTM.RotateToCompass().Find(self.MaxOffset, self.MaxScale, self.MaxInaccuracy);
    if Res.Arr = [] then Wait(60);
  end;
  Result := Res.Arr <> [];
end;

(*
  Just a neat function to have..
  It locates the "goal" point taking into account all minimap transformations..
  Then it returns the distance from you (at minimap center) to this point.
*)
function TObjectWalk.DistanceTo(Goal:TPoint; DTM:TMMDTM): Double; constref;
var
  F:TFoundFeatures;
  other,me:TPoint;
  i:Int32;
begin
  Goal.x -= DTM[0].x;
  Goal.y -= DTM[0].y;
  me := minimap.Center;
  F := DTM.RotateToCompass().Find(self.MaxOffset, self.MaxScale, self.MaxInaccuracy);

  other := self.GetPoint(Goal, F.arr[0], F.theta, F.scale);
  Result := Hypot(me.x-other.x, me.y-other.y);
end;

(*
  Yeah.. this one is supersimple, with no random at all (this is a prototype after all).
*)

procedure TObjectWalk.WalkTo(pt:TPoint); constref;
begin
  Mouse.Click(pt,1);
  while self.IsFlagPresent() do
    Wait(70);
end;

(*
  This is your best friend. It will walk the minimap up, down, and sideways, yo!
*)
function TObjectWalk.Walk(Path:TMMPath): Boolean; constref;
var
  i:Int32;
  step,pt:TPoint;
  F:TFoundFeatures;
begin
  for i:=0 to High(Path) do
  begin
    for step in Path[i].Points do
    begin
      {$IFDEF SMART}
      if self.Debugging then
      begin
        self.DebugDTM(step, Path[i].Features, smart.Image);
        Wait(100);
      end;
      {$ENDIF}

      if not self.FindDTM(F,Path[i].Features) then
      begin
        WriteLn('Warning: Unable to find DTM ', i);
        Exit(False);
      end;

      pt.x := step.x - Path[i].Features[0].x;
      pt.y := step.y - Path[i].Features[0].y;
      pt := self.GetPoint(pt, F.arr[0], F.theta, F.scale);

      {$IFDEF SMART}
      if self.Debugging then smart.Image.DrawClear(0);
      {$ENDIF}

      self.WalkTo(pt);
    end;
  end;
  Result := True;
end;



(*==| FOR DEBUGGING BELLOW THIS LINE |========================================*)
(*============================================================================*)

procedure TObjectWalk.DebugMinimap(im:TMufasaBitmap; offset:TPoint=[0,0]; Clear:Boolean=True); constref;
var
  objects: T2DPointArray;
  color,i:Int32;
  pt:TPoint;
  b:TBox;
begin
  SetLength(objects, 0);
  for i:=0 to High(MMObjRecords) do
    objects += Minimap.FindObj(MMObjRecords[i]);

  if Clear then im.DrawClear(0);
  for i:=0 to High(objects) do
    for pt in objects[i] do
    begin
      color := COLOR_LIST16[i mod 16];
      Im.SetPixel(offset.x+pt.x, offset.y+pt.y, $FFFFFF);
      try
      Im.DrawTPA(TPAFromCircle(offset.x+pt.x, offset.y+pt.y, 4), color);
      except
      end;
    end;
end;


procedure TObjectWalk.DebugDTM(Goal:TPoint; DTM:TMMDTM; im:TMufasaBitmap; offset:TPoint=[0,0]; Clear:Boolean=True); constref;
var
  F:TFoundFeatures;
  found:TPoint;
  i,color:Int32;
begin
  Goal.x -= DTM[0].x;
  Goal.y -= DTM[0].y;

  F := DTM.RotateToCompass().Find(self.MaxOffset, self.MaxScale, self.MaxInaccuracy);
  if F.arr = [] then
  begin
    WriteLn('Unable to find DTM!');
    Exit;
  end;
  found := self.GetPoint(Goal, F.arr[0], F.theta, F.scale);
  if Clear then im.DrawClear(0);

  Im.SetPixel(offset.x+found.x, offset.y+found.y, $FFFFFF);
  Im.DrawTPA(TPAFromCircle(offset.x+found.x, offset.y+found.y, 4), COLOR_LIST16[0]);

  for i:=0 to High(F.arr) do
  begin
    color := COLOR_LIST16[(i+1) mod 16];
    Im.SetPixel(offset.x+F.arr[i].x, offset.y+F.arr[i].y, $FFFFFF);
    try
    Im.DrawTPA(TPAFromCircle(offset.x+F.arr[i].x, offset.y+F.arr[i].y, 4), color);
    except
    end;
  end;
end;

